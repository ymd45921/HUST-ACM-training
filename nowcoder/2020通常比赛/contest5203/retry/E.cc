/**
 *
 * T了还行
 * 这是什么规律题
 *
 * 解法：
 * 斐波拉契数列打表；n皇后打表；100以内素数打表
 * 是斐波拉契数就直接输出打表皇后，否则：
 * - 模数m分解质因数：ni个pi，i:1~k
 * - 结论：m为基时末位0 = min(f(x,pi)/ni)
 * - f(x,pi)指1~x中所有数中pi作为质因数次数总和
 * - 可以遍历x，当然最好是x / pi^a，加算/ni
 * 这样就可以方便的算出这个结论了；
 * 那么这个结论是哪儿来的呢？显然，每个pi都要出现ni次，才能
 * 让末尾0多1个；所以能凑齐几套就看份数最少的；此外，这个要
 * 的pi出现次数也可以这种方法快速统计（避免遍历）
 *
 * 感觉那个末尾10，应该是因为10 = 5*2，5出现就必有2吧
 * 但是那个递归也是意义不明（虽然最后写成迭代的
 * 证明使用的是分情况，x > 5时提取含5的式子，证明一定有足够2
 *
 * 有点在意之前网上查到的10的倍数的递归：
 * https://www.cnblogs.com/hutonm/p/5624996.html
 */
#include <iostream>
#include <algorithm>
#include <functional>

using namespace std;
using longs = long long;
using longd = long double;
using ulongs = unsigned long long;

const int inf = 0x3f3f3f3f;
const int mod = 1e9+7;
const longs INF = 0x3f3f3f3f3f3f3f3f;
const double eps = 1e-8;

const longs ffib[] =
        {
                0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987,
                1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393,
                196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887,
                9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141,
                267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073,
                4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173,
                86267571272, 139583862445, 225851433717, 365435296162, 591286729879,
                956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842,
                10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141,
                117669030460994, 190392490709135, 308061521170129, 498454011879264,
                806515533049393, 1304969544928657, 2111485077978050, 3416454622906707,
                5527939700884757, 8944394323791464, 14472334024676221, 23416728348467685,
                37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088,
                259695496911122585, 420196140727489673, 679891637638612258,
                1100087778366101931, 1779979416004714189, 2880067194370816120,
                4660046610375530309, 7540113804746346429
        };
const longs nqueen[] =
        {
                0,
                1, 0, 0, 2, 10,
                4, 40, 92, 352, 724,
                2680, 14200, 73712, 365596, 2279184,
                14772512, 95815104, 666090624, 4968057848, 39029188884,
                314666222712, 2691008701644, 24233937684440, 227514171973736, 2207893435808352
        };
const int prime[] =
        {
                1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 47,
                53, 59, 61, 67, 71, 73, 79, 83, 89, 97
        };
#define FIB ffib, ffib+93

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    longs x, ans;
    int m;

    function<longs(longs)> solvezero = [&](longs n)
    {
        longs ret = INF<<1; int cnt[25]{0}, base = m;
        for (int i = 1; i < 25; ++ i)
        {
            if (prime[i] > m) break;
            while (base % prime[i] == 0)
                ++ cnt[i], base /= prime[i];
        }
        for (int i = 1; i < 25; ++ i)
            if (cnt[i])
            {
                const int& p = prime[i];
                longs num = 0, lim = n / p;
                for (longs cc = p; cc <= n; cc *= p)
                {
                    num += n / cc;
                    if (cc > lim) break;
                }
                ret = min(ret, num / cnt[i]);
            }
        return ans = ret;
    };

    auto solvequeen = [&]
    {
        longs z = x % min(13, m) + 1;
        ans = nqueen[z];
    };

    cin >> x >> m;
    auto ll = lower_bound(FIB, x);
    auto rr = upper_bound(FIB, x);
    if (rr - ll == 1) solvezero(x);
    else solvequeen();
    cout << ans << endl;

    return 0;
}